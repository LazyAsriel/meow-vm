================================================================================
 FILE PATH: include/meow/core/array.h
================================================================================
     1	/**
     2	 * @file array.h
     3	 * @author LazyPaws
     4	 * @brief Core definition of Array in TrangMeo
     5	 */
     6	
     7	#pragma once
     8	
     9	#include <cstdint>
    10	#include <vector>
    11	#include <meow/core/meow_object.h>
    12	#include <meow/value.h>
    13	#include <meow/memory/gc_visitor.h>
    14	
    15	namespace meow {
    16	class ObjArray : public ObjBase<ObjectType::ARRAY> {
    17	public:
    18	    using container_t = std::vector<value_t>;
    19	    
    20	private:
    21	    using visitor_t = GCVisitor;
    22	    container_t elements_;
    23	
    24	public:
    25	    explicit ObjArray() = default;
    26	
    27	    ObjArray(const std::vector<value_t>& elements) 
    28	        : elements_(elements) {}
    29	
    30	    ObjArray(container_t&& elements) noexcept 
    31	        : elements_(std::move(elements)) {}
    32	
    33	    // --- Rule of 5 ---
    34	    ObjArray(const ObjArray&) = delete;
    35	    ObjArray(ObjArray&&) = default;
    36	    ObjArray& operator=(const ObjArray&) = delete;
    37	    ObjArray& operator=(ObjArray&&) = delete;
    38	    ~ObjArray() override = default;
    39	
    40	    // --- Size Override ---
    41	    size_t obj_size() const noexcept override { return sizeof(ObjArray); }
    42	
    43	    // --- Iterator types ---
    44	    using iterator = container_t::iterator;
    45	    using const_iterator = container_t::const_iterator;
    46	    using reverse_iterator = container_t::reverse_iterator;
    47	    using const_reverse_iterator = container_t::const_reverse_iterator;
    48	
    49	    // --- Accessors & Modifiers ---
    50	    
    51	    template <typename Self>
    52	    inline decltype(auto) get(this Self&& self, size_t index) noexcept {
    53	        return std::forward<Self>(self).elements_[index]; 
    54	    }
    55	
    56	    template <typename Self>
    57	    inline decltype(auto) at(this Self&& self, size_t index) {
    58	        return std::forward<Self>(self).elements_.at(index);
    59	    }
    60	
    61	    template <typename Self>
    62	    inline decltype(auto) operator[](this Self&& self, size_t index) noexcept {
    63	        return std::forward<Self>(self).elements_[index];
    64	    }
    65	
    66	    template <typename Self>
    67	    inline decltype(auto) front(this Self&& self) noexcept {
    68	        return std::forward<Self>(self).elements_.front();
    69	    }
    70	
    71	    template <typename Self>
    72	    inline decltype(auto) back(this Self&& self) noexcept {
    73	        return std::forward<Self>(self).elements_.back();
    74	    }
    75	
    76	    template <typename T>
    77	    inline void set(size_t index, T&& value) noexcept {
    78	        elements_[index] = std::forward<T>(value);
    79	    }
    80	
    81	    inline size_t size() const noexcept { return elements_.size(); }
    82	    inline bool empty() const noexcept { return elements_.empty(); }
    83	    inline size_t capacity() const noexcept { return elements_.capacity(); }
    84	
    85	    template <typename T>
    86	    inline void push(T&& value) { elements_.emplace_back(std::forward<T>(value)); }
    87	    inline void pop() noexcept { elements_.pop_back(); }
    88	    
    89	    template <typename... Args>
    90	    inline void emplace(Args&&... args) { elements_.emplace_back(std::forward<Args>(args)...); }
    91	    
    92	    inline void resize(size_t size) { elements_.resize(size); }
    93	    inline void reserve(size_t capacity) { elements_.reserve(capacity); }
    94	    inline void shrink() { elements_.shrink_to_fit(); }
    95	    inline void clear() { elements_.clear(); }
    96	
    97	    template <typename Self>
    98	    inline auto begin(this Self&& self) noexcept { return std::forward<Self>(self).elements_.begin(); }
    99	    
   100	    template <typename Self>
   101	    inline auto end(this Self&& self) noexcept { return std::forward<Self>(self).elements_.end(); }
   102	
   103	    template <typename Self>
   104	    inline auto rbegin(this Self&& self) noexcept { return std::forward<Self>(self).elements_.rbegin(); }
   105	
   106	    template <typename Self>
   107	    inline auto rend(this Self&& self) noexcept { return std::forward<Self>(self).elements_.rend(); }
   108	
   109	    void trace(visitor_t& visitor) const noexcept override;
   110	};
   111	}


================================================================================
 FILE PATH: include/meow/core/function.h
================================================================================
     1	/**
     2	 * @file function.h
     3	 * @author LazyPaws
     4	 * @brief Core definition of Upvalue, Proto, Function in TrangMeo
     5	 * @copyright Copyright (c) 2025 LazyPaws
     6	 * @license All rights reserved. Unauthorized copying of this file, in any form
     7	 * or medium, is strictly prohibited
     8	 */
     9	
    10	#pragma once
    11	
    12	#include <cstdint>
    13	#include <vector>
    14	#include <string>
    15	#include <memory>
    16	#include <meow/definitions.h>
    17	#include <meow/core/meow_object.h>
    18	#include <meow/definitions.h>
    19	#include <meow/value.h>
    20	#include <meow/memory/gc_visitor.h>
    21	#include "meow/bytecode/chunk.h"
    22	
    23	namespace meow {
    24	struct UpvalueDesc {
    25	    bool is_local_;
    26	    size_t index_;
    27	    UpvalueDesc(bool is_local = false, size_t index = 0) noexcept : is_local_(is_local), index_(index) {
    28	    }
    29	};
    30	
    31	class ObjUpvalue : public ObjBase<ObjectType::UPVALUE> {
    32	   private:
    33	    using visitor_t = GCVisitor;
    34	
    35	    enum class State { OPEN, CLOSED };
    36	    State state_ = State::OPEN;
    37	    size_t index_ = 0;
    38	    Value closed_ = null_t{};
    39	
    40	   public:
    41	    explicit ObjUpvalue(size_t index = 0) noexcept : index_(index) {
    42	    }
    43	    inline void close(param_t value) noexcept {
    44	        closed_ = value;
    45	        state_ = State::CLOSED;
    46	    }
    47	    inline bool is_closed() const noexcept {
    48	        return state_ == State::CLOSED;
    49	    }
    50	    inline return_t get_value() const noexcept {
    51	        return closed_;
    52	    }
    53	    inline size_t get_index() const noexcept {
    54	        return index_;
    55	    }
    56	
    57	    size_t obj_size() const noexcept override { return sizeof(ObjUpvalue); }
    58	
    59	    void trace(visitor_t& visitor) const noexcept override;
    60	};
    61	
    62	class ObjFunctionProto : public ObjBase<ObjectType::PROTO> {
    63	private:
    64	    using chunk_t = Chunk;
    65	    using string_t = string_t;
    66	    using visitor_t = GCVisitor;
    67	
    68	    size_t num_registers_;
    69	    size_t num_upvalues_;
    70	    string_t name_;
    71	    chunk_t chunk_;
    72	    module_t module_ = nullptr;
    73	    std::vector<UpvalueDesc> upvalue_descs_;
    74	
    75	public:
    76	    explicit ObjFunctionProto(size_t registers, size_t upvalues, string_t name, chunk_t&& chunk) noexcept : num_registers_(registers), num_upvalues_(upvalues), name_(name), chunk_(std::move(chunk)) {
    77	    }
    78	    explicit ObjFunctionProto(size_t registers, size_t upvalues, string_t name, chunk_t&& chunk, std::vector<UpvalueDesc>&& descs) noexcept
    79	        : num_registers_(registers), num_upvalues_(upvalues), name_(name), chunk_(std::move(chunk)), upvalue_descs_(std::move(descs)) {
    80	    }
    81	
    82	    inline void set_module(module_t mod) noexcept { module_ = mod; }
    83	    inline module_t get_module() const noexcept { return module_; }
    84	
    85	    /// @brief Unchecked upvalue desc access. For performance-critical code
    86	    inline const UpvalueDesc& get_desc(size_t index) const noexcept {
    87	        return upvalue_descs_[index];
    88	    }
    89	    /// @brief Checked upvalue desc access. For performence-critical code
    90	    inline const UpvalueDesc& at_desc(size_t index) const {
    91	        return upvalue_descs_.at(index);
    92	    }
    93	    inline size_t get_num_registers() const noexcept {
    94	        return num_registers_;
    95	    }
    96	    inline size_t get_num_upvalues() const noexcept {
    97	        return num_upvalues_;
    98	    }
    99	    inline string_t get_name() const noexcept {
   100	        return name_;
   101	    }
   102	    inline const chunk_t& get_chunk() const noexcept {
   103	        return chunk_;
   104	    }
   105	    inline size_t desc_size() const noexcept {
   106	        return upvalue_descs_.size();
   107	    }
   108	
   109	    size_t obj_size() const noexcept override { return sizeof(ObjFunctionProto); }
   110	
   111	    void trace(visitor_t& visitor) const noexcept override;
   112	};
   113	
   114	class ObjClosure : public ObjBase<ObjectType::FUNCTION> {
   115	   private:
   116	    using proto_t = proto_t;
   117	    using upvalue_t = upvalue_t;
   118	    using visitor_t = GCVisitor;
   119	
   120	    proto_t proto_;
   121	    std::vector<upvalue_t> upvalues_;
   122	
   123	   public:
   124	    explicit ObjClosure(proto_t proto = nullptr) : proto_(proto), upvalues_(proto ? proto->get_num_upvalues() : 0) {}
   125	
   126	    inline proto_t get_proto() const noexcept {
   127	        return proto_;
   128	    }
   129	    /// @brief Unchecked upvalue access. For performance-critical code
   130	    inline upvalue_t get_upvalue(size_t index) const noexcept {
   131	        return upvalues_[index];
   132	    }
   133	    /// @brief Unchecked upvalue modification. For performance-critical code
   134	    inline void set_upvalue(size_t index, upvalue_t upvalue) noexcept {
   135	        upvalues_[index] = upvalue;
   136	    }
   137	    /// @brief Checked upvalue access. Throws if index is OOB
   138	    inline upvalue_t at_upvalue(size_t index) const {
   139	        return upvalues_.at(index);
   140	    }
   141	
   142	    size_t obj_size() const noexcept override { return sizeof(ObjClosure); }
   143	
   144	    void trace(visitor_t& visitor) const noexcept override;
   145	};
   146	}


================================================================================
 FILE PATH: include/meow/core/hash_table.h
================================================================================
     1	/**
     2	 * @file hash_table.h
     3	 * @brief Optimized Hash Table with State-ful Allocator (meow::allocator)
     4	 * Compatible with std::map semantics (first/second)
     5	 */
     6	
     7	#pragma once
     8	
     9	#include <cstdint>
    10	#include <cstring>
    11	#include <bit> 
    12	#include <meow/definitions.h>
    13	#include <meow/core/meow_object.h>
    14	#include <meow/value.h>
    15	#include <meow/memory/gc_visitor.h>
    16	#include <meow/core/string.h>
    17	#include <meow_allocator.h> 
    18	
    19	namespace meow {
    20	
    21	struct Entry {
    22	    string_t first = nullptr;
    23	    Value second;
    24	};
    25	
    26	class ObjHashTable : public ObjBase<ObjectType::HASH_TABLE> {
    27	public:
    28	    using Allocator = meow::allocator<Entry>;
    29	
    30	private:
    31	    Entry* entries_ = nullptr;
    32	    uint32_t count_ = 0;
    33	    uint32_t capacity_ = 0;
    34	    uint32_t mask_ = 0;
    35	    
    36	    [[no_unique_address]] Allocator alloc_;
    37	
    38	    static constexpr double MAX_LOAD_FACTOR = 0.75;
    39	    static constexpr uint32_t MIN_CAPACITY = 8;
    40	
    41	public:
    42	    explicit ObjHashTable(Allocator alloc, uint32_t cap = 0) 
    43	        : alloc_(alloc) {
    44	        if (cap > 0) allocate(cap);
    45	    }
    46	
    47	    ~ObjHashTable() override {
    48	        if (entries_) {
    49	            alloc_.deallocate(entries_, capacity_);
    50	        }
    51	    }
    52	
    53	    // --- Core Operations ---
    54	
    55	    [[gnu::always_inline]] 
    56	    inline Entry* find_entry(Entry* entries, uint32_t mask, string_t key) const {
    57	        uint32_t index = key->hash() & mask;
    58	        for (;;) {
    59	            Entry* entry = &entries[index];
    60	            if (entry->first == key || entry->first == nullptr) [[likely]] {
    61	                return entry;
    62	            }
    63	            index = (index + 1) & mask;
    64	        }
    65	    }
    66	
    67	    [[gnu::always_inline]] 
    68	    inline bool set(string_t key, Value value) {
    69	        if (count_ + 1 > (capacity_ * MAX_LOAD_FACTOR)) [[unlikely]] {
    70	            grow();
    71	        }
    72	
    73	        Entry* entry = find_entry(entries_, mask_, key);
    74	        bool is_new = (entry->first == nullptr);
    75	        
    76	        if (is_new) [[likely]] {
    77	            count_++;
    78	            entry->first = key;
    79	        }
    80	        entry->second = value;
    81	        return is_new;
    82	    }
    83	
    84	    [[gnu::always_inline]] 
    85	    inline bool get(string_t key, Value* result) const {
    86	        if (count_ == 0) [[unlikely]] return false;
    87	        Entry* entry = find_entry(entries_, mask_, key);
    88	        if (entry->first == nullptr) return false;
    89	        *result = entry->second;
    90	        return true;
    91	    }
    92	
    93	    [[gnu::always_inline]]
    94	    inline Value get(string_t key) const {
    95	        if (count_ == 0) return Value(null_t{});
    96	        Entry* entry = find_entry(entries_, mask_, key);
    97	        if (entry->first == nullptr) return Value(null_t{});
    98	        return entry->second;
    99	    }
   100	
   101	    [[gnu::always_inline]] 
   102	    inline bool has(string_t key) const {
   103	        if (count_ == 0) return false;
   104	        return find_entry(entries_, mask_, key)->first != nullptr;
   105	    }
   106	
   107	    bool remove(string_t key) {
   108	        if (count_ == 0) return false;
   109	        Entry* entry = find_entry(entries_, mask_, key);
   110	        if (entry->first == nullptr) return false;
   111	
   112	        entry->first = nullptr;
   113	        entry->second = Value(null_t{});
   114	        count_--;
   115	
   116	        uint32_t index = (uint32_t)(entry - entries_);
   117	        uint32_t next_index = index;
   118	
   119	        for (;;) {
   120	            next_index = (next_index + 1) & mask_;
   121	            Entry* next = &entries_[next_index];
   122	            if (next->first == nullptr) break;
   123	
   124	            uint32_t ideal = next->first->hash() & mask_;
   125	            bool shift = false;
   126	            if (index < next_index) {
   127	                if (ideal <= index || ideal > next_index) shift = true;
   128	            } else {
   129	                if (ideal <= index && ideal > next_index) shift = true;
   130	            }
   131	
   132	            if (shift) {
   133	                entries_[index] = *next;
   134	                entries_[next_index].first = nullptr;
   135	                entries_[next_index].second = Value(null_t{});
   136	                index = next_index;
   137	            }
   138	        }
   139	        return true;
   140	    }
   141	
   142	    // --- Capacity ---
   143	    inline uint32_t size() const noexcept { return count_; }
   144	    inline bool empty() const noexcept { return count_ == 0; }
   145	    inline uint32_t capacity() const noexcept { return capacity_; }
   146	
   147	    class Iterator {
   148	        Entry* ptr_; Entry* end_;
   149	    public:
   150	        Iterator(Entry* ptr, Entry* end) : ptr_(ptr), end_(end) {
   151	            while (ptr_ < end_ && ptr_->first == nullptr) ptr_++;
   152	        }
   153	        Iterator& operator++() {
   154	            do { ptr_++; } while (ptr_ < end_ && ptr_->first == nullptr);
   155	            return *this;
   156	        }
   157	        bool operator!=(const Iterator& other) const { return ptr_ != other.ptr_; }
   158	        
   159	        Entry& operator*() const { return *ptr_; }
   160	        Entry* operator->() const { return ptr_; }
   161	    };
   162	
   163	    inline Iterator begin() { return Iterator(entries_, entries_ + capacity_); }
   164	    inline Iterator end() { return Iterator(entries_ + capacity_, entries_ + capacity_); }
   165	
   166	    size_t obj_size() const noexcept override {
   167	        return sizeof(ObjHashTable) + sizeof(Entry) * capacity_;
   168	    }
   169	
   170	    void trace(GCVisitor& visitor) const noexcept override {
   171	        for (uint32_t i = 0; i < capacity_; i++) {
   172	            if (entries_[i].first) {
   173	                visitor.visit_object(entries_[i].first);
   174	                visitor.visit_value(entries_[i].second);
   175	            }
   176	        }
   177	    }
   178	
   179	private:
   180	    void allocate(uint32_t capacity) {
   181	        capacity_ = (capacity < MIN_CAPACITY) ? MIN_CAPACITY : std::bit_ceil(capacity);
   182	        mask_ = capacity_ - 1;
   183	        
   184	        entries_ = alloc_.allocate(capacity_);
   185	        std::memset(static_cast<void*>(entries_), 0, sizeof(Entry) * capacity_);
   186	    }
   187	
   188	    void grow() {
   189	        uint32_t old_cap = capacity_;
   190	        Entry* old_entries = entries_;
   191	
   192	        allocate(old_cap == 0 ? MIN_CAPACITY : old_cap * 2);
   193	        count_ = 0;
   194	
   195	        if (old_entries) {
   196	            for (uint32_t i = 0; i < old_cap; i++) {
   197	                if (old_entries[i].first != nullptr) {
   198	                    Entry* dest = find_entry(entries_, mask_, old_entries[i].first);
   199	                    dest->first = old_entries[i].first;
   200	                    dest->second = old_entries[i].second;
   201	                    count_++;
   202	                }
   203	            }
   204	            alloc_.deallocate(old_entries, old_cap);
   205	        }
   206	    }
   207	};
   208	
   209	} // namespace meow


================================================================================
 FILE PATH: include/meow/core/meow_object.h
================================================================================
     1	#pragma once
     2	#include <cstdint>
     3	
     4	namespace meow {
     5	struct GCVisitor;
     6	
     7	enum class GCState : uint8_t {
     8	    UNMARKED = 0, MARKED = 1, OLD = 2
     9	};
    10	
    11	enum class ObjectType : uint8_t {
    12	    ARRAY = 6, STRING, HASH_TABLE, INSTANCE, CLASS,
    13	    BOUND_METHOD, UPVALUE, PROTO, FUNCTION, MODULE, SHAPE
    14	};
    15	
    16	struct MeowObject {
    17	    const ObjectType type;
    18	    GCState gc_state = GCState::UNMARKED;
    19	
    20	    explicit MeowObject(ObjectType type_tag) noexcept : type(type_tag) {}
    21	    virtual ~MeowObject() = default;
    22	    
    23	    virtual void trace(GCVisitor& visitor) const noexcept = 0;
    24	    
    25	    virtual size_t obj_size() const noexcept = 0;
    26	
    27	    inline ObjectType get_type() const noexcept { return type; }
    28	    inline bool is_marked() const noexcept { return gc_state != GCState::UNMARKED; }
    29	    inline void mark() noexcept { if (gc_state == GCState::UNMARKED) gc_state = GCState::MARKED; }
    30	    inline void unmark() noexcept { if (gc_state != GCState::OLD) gc_state = GCState::UNMARKED; }
    31	};
    32	
    33	template <ObjectType type_tag>
    34	struct ObjBase : public MeowObject {
    35	    ObjBase() noexcept : MeowObject(type_tag) {}
    36	};
    37	}


================================================================================
 FILE PATH: include/meow/core/module.h
================================================================================
     1	#pragma once
     2	
     3	#include <cstdint>
     4	#include <vector>
     5	#include <string>
     6	#include <memory>
     7	#include <meow/definitions.h>
     8	#include <meow/core/meow_object.h>
     9	#include <meow/definitions.h>
    10	#include <meow/value.h>
    11	#include <meow/memory/gc_visitor.h>
    12	#include <meow_flat_map.h>
    13	
    14	namespace meow {
    15	class ObjModule : public ObjBase<ObjectType::MODULE> {
    16	private:
    17	    using string_t = string_t;
    18	    using proto_t = proto_t;
    19	    using visitor_t = GCVisitor;
    20	
    21	    enum class State { INITIAL, EXECUTING, EXECUTED };
    22	
    23	    std::vector<Value> globals_store_;
    24	    
    25	    using GlobalNameMap = meow::flat_map<string_t, uint32_t>;
    26	    using ExportMap = meow::flat_map<string_t, value_t>;
    27	
    28	    GlobalNameMap global_names_;
    29	    ExportMap exports_;
    30	    
    31	    string_t file_name_;
    32	    string_t file_path_;
    33	    proto_t main_proto_;
    34	
    35	    State state;
    36	
    37	public:
    38	    explicit ObjModule(string_t file_name, string_t file_path, proto_t main_proto = nullptr) noexcept 
    39	        : file_name_(file_name), file_path_(file_path), main_proto_(main_proto), state(State::INITIAL) {}
    40	    
    41	    [[gnu::always_inline]]
    42	    inline return_t get_global_by_index(uint32_t index) const noexcept {
    43	        return globals_store_[index];
    44	    }
    45	
    46	    [[gnu::always_inline]]
    47	    inline void set_global_by_index(uint32_t index, param_t value) noexcept {
    48	        globals_store_[index] = value;
    49	    }
    50	
    51	    uint32_t intern_global(string_t name) {
    52	        uint32_t next_idx = static_cast<uint32_t>(globals_store_.size());
    53	        auto [ptr, inserted] = global_names_.try_emplace(name, next_idx);
    54	        
    55	        if (inserted) {
    56	            globals_store_.push_back(Value(null_t{}));
    57	        }
    58	        
    59	        return *ptr;
    60	    }
    61	
    62	    inline bool has_global(string_t name) {
    63	        return global_names_.contains(name);
    64	    }
    65	
    66	    inline return_t get_global(string_t name) noexcept {
    67	        if (auto* idx_ptr = global_names_.find(name)) {
    68	            return globals_store_[*idx_ptr];
    69	        }
    70	        return Value(null_t{});
    71	    }
    72	
    73	    inline void set_global(string_t name, param_t value) noexcept {
    74	        uint32_t idx = intern_global(name);
    75	        globals_store_[idx] = value;
    76	    }
    77	
    78	    inline void import_all_global(const module_t other) noexcept {
    79	        const auto& other_keys = other->global_names_.keys();
    80	        const auto& other_vals = other->global_names_.values();
    81	        
    82	        for (size_t i = 0; i < other_keys.size(); ++i) {
    83	            Value val = other->globals_store_[other_vals[i]];
    84	            set_global(other_keys[i], val);
    85	        }
    86	    }
    87	
    88	    // --- Exports ---
    89	    inline return_t get_export(string_t name) noexcept {
    90	        if (auto* val_ptr = exports_.find(name)) {
    91	            return *val_ptr;
    92	        }
    93	        return Value(null_t{});
    94	    }
    95	    
    96	    inline void set_export(string_t name, param_t value) noexcept {
    97	        exports_[name] = value; 
    98	    }
    99	    
   100	    inline bool has_export(string_t name) {
   101	        return exports_.contains(name);
   102	    }
   103	    
   104	    inline void import_all_export(const module_t other) noexcept {
   105	        const auto& other_keys = other->exports_.keys();
   106	        const auto& other_vals = other->exports_.values();
   107	        
   108	        for (size_t i = 0; i < other_keys.size(); ++i) {
   109	            exports_.try_emplace(other_keys[i], other_vals[i]);
   110	        }
   111	    }
   112	
   113	    inline string_t get_file_name() const noexcept { return file_name_; }
   114	    inline string_t get_file_path() const noexcept { return file_path_; }
   115	    inline proto_t get_main_proto() const noexcept { return main_proto_; }
   116	    inline void set_main_proto(proto_t proto) noexcept { main_proto_ = proto; }
   117	    inline bool is_has_main() const noexcept { return main_proto_ != nullptr; }
   118	
   119	    inline void set_execution() noexcept { state = State::EXECUTING; }
   120	    inline void set_executed() noexcept { state = State::EXECUTED; }
   121	    inline bool is_executing() const noexcept { return state == State::EXECUTING; }
   122	    inline bool is_executed() const noexcept { return state == State::EXECUTED; }
   123	
   124	    friend void obj_module_trace(const ObjModule* mod, visitor_t& visitor);
   125	    void trace(visitor_t& visitor) const noexcept override;
   126	    
   127	    const auto& get_global_names_raw() const { return global_names_; }
   128	    const auto& get_exports_raw() const { return exports_; }
   129	
   130	    size_t obj_size() const noexcept override { return sizeof(ObjModule); }
   131	};
   132	}


================================================================================
 FILE PATH: include/meow/core/objects.h
================================================================================
     1	#pragma once
     2	
     3	#include <meow/core/array.h>
     4	#include <meow/core/function.h>
     5	#include <meow/core/hash_table.h>
     6	#include <meow/core/module.h>
     7	#include <meow/core/oop.h>
     8	#include <meow/core/string.h>
     9	#include <meow/core/shape.h>
    10	#include <meow/memory/gc_visitor.h>


================================================================================
 FILE PATH: include/meow/core/oop.h
================================================================================
     1	/**
     2	 * @file oop.h
     3	 * @author LazyPaws
     4	 * @brief Core definition of Class, Instance, BoundMethod in TrangMeo
     5	 * @copyright Copyright (c) 2025 LazyPaws
     6	 * @license All rights reserved. Unauthorized copying of this file, in any form
     7	 * or medium, is strictly prohibited
     8	 */
     9	
    10	#pragma once
    11	
    12	#include <cstdint>
    13	#include <vector>
    14	#include <string>
    15	#include <memory>
    16	#include <meow/definitions.h>
    17	#include <meow/core/meow_object.h>
    18	#include <meow/definitions.h>
    19	#include <meow/value.h>
    20	#include <meow/memory/gc_visitor.h>
    21	#include <meow/core/shape.h>
    22	#include <meow_flat_map.h>
    23	
    24	namespace meow {
    25	class ObjClass : public ObjBase<ObjectType::CLASS> {
    26	private:
    27	    using string_t = string_t;
    28	    using class_t = class_t;
    29	    using method_map = meow::flat_map<string_t, value_t>;
    30	    using visitor_t = GCVisitor;
    31	
    32	    string_t name_;
    33	    class_t superclass_;
    34	    method_map methods_;
    35	
    36	public:
    37	    explicit ObjClass(string_t name = nullptr) noexcept : name_(name) {}
    38	
    39	    // --- Metadata ---
    40	    inline string_t get_name() const noexcept {
    41	        return name_;
    42	    }
    43	    inline class_t get_super() const noexcept {
    44	        return superclass_;
    45	    }
    46	    inline void set_super(class_t super) noexcept {
    47	        superclass_ = super;
    48	    }
    49	
    50	    // --- Methods ---
    51	    inline bool has_method(string_t name) const noexcept {
    52	        return methods_.contains(name);
    53	    }
    54	    
    55	    inline return_t get_method(string_t name) noexcept {
    56	        if (auto* val_ptr = methods_.find(name)) {
    57	            return *val_ptr;
    58	        }
    59	        return Value(null_t{});
    60	    }
    61	    
    62	    inline void set_method(string_t name, param_t value) noexcept {
    63	        methods_[name] = value;
    64	    }
    65	
    66	    size_t obj_size() const noexcept override { return sizeof(ObjClass); }
    67	
    68	    void trace(visitor_t& visitor) const noexcept override;
    69	};
    70	
    71	class ObjInstance : public ObjBase<ObjectType::INSTANCE> {
    72	private:
    73	    using string_t = string_t;
    74	    using class_t = class_t;
    75	    using visitor_t = GCVisitor;
    76	
    77	    class_t klass_;
    78	    Shape* shape_;              
    79	    std::vector<Value> fields_; 
    80	public:
    81	    explicit ObjInstance(class_t k, Shape* empty_shape) noexcept 
    82	        : klass_(k), shape_(empty_shape) {
    83	    }
    84	
    85	    // --- Metadata ---
    86	    inline class_t get_class() const noexcept { return klass_; }
    87	    inline void set_class(class_t klass) noexcept { klass_ = klass; }
    88	
    89	    inline Shape* get_shape() const noexcept { return shape_; }
    90	    inline void set_shape(Shape* s) noexcept { shape_ = s; }
    91	
    92	    inline Value get_field_at(int offset) const noexcept {
    93	        return fields_[offset];
    94	    }
    95	    
    96	    inline void set_field_at(int offset, Value value) noexcept {
    97	        fields_[offset] = value;
    98	    }
    99	    
   100	    inline void add_field(param_t value) noexcept {
   101	        fields_.push_back(value);
   102	    }
   103	
   104	    inline bool has_field(string_t name) const {
   105	        return shape_->get_offset(name) != -1;
   106	    }
   107	    
   108	    inline Value get_field(string_t name) const {
   109	        int offset = shape_->get_offset(name);
   110	        if (offset != -1) return fields_[offset];
   111	        return Value(null_t{});
   112	    }
   113	
   114	    size_t obj_size() const noexcept override { return sizeof(ObjInstance); }
   115	
   116	    void trace(visitor_t& visitor) const noexcept override {
   117	        visitor.visit_object(klass_);
   118	        visitor.visit_object(shape_);
   119	        for (const auto& val : fields_) {
   120	            visitor.visit_value(val);
   121	        }
   122	    }
   123	};
   124	
   125	class ObjBoundMethod : public ObjBase<ObjectType::BOUND_METHOD> {
   126	private:
   127	    Value receiver_; 
   128	    Value method_;   
   129	
   130	    using visitor_t = GCVisitor;
   131	public:
   132	    explicit ObjBoundMethod(Value receiver, Value method) noexcept 
   133	        : receiver_(receiver), method_(method) {}
   134	
   135	    inline Value get_receiver() const noexcept { return receiver_; }
   136	    inline Value get_method() const noexcept { return method_; }
   137	
   138	    size_t obj_size() const noexcept override { return sizeof(ObjBoundMethod); }
   139	
   140	    void trace(visitor_t& visitor) const noexcept override {
   141	        visitor.visit_value(receiver_);
   142	        visitor.visit_value(method_);
   143	    }
   144	};
   145	}


================================================================================
 FILE PATH: include/meow/core/shape.h
================================================================================
     1	#pragma once
     2	
     3	#include <cstdint>
     4	#include <vector>
     5	#include <string>
     6	#include <memory>
     7	#include <meow/definitions.h>
     8	#include <meow/core/meow_object.h>
     9	#include <meow/memory/gc_visitor.h>
    10	#include <meow/core/string.h>
    11	#include <meow_flat_map.h>
    12	
    13	namespace meow {
    14	
    15	class MemoryManager; 
    16	
    17	class Shape : public ObjBase<ObjectType::SHAPE> {
    18	public:
    19	    using TransitionMap = meow::flat_map<string_t, Shape*>;
    20	    using PropertyMap = meow::flat_map<string_t, uint32_t>;
    21	
    22	private:
    23	    PropertyMap property_offsets_;
    24	    TransitionMap transitions_;     
    25	    uint32_t num_fields_ = 0;       
    26	
    27	public:
    28	    explicit Shape() = default;
    29	
    30	    int get_offset(string_t name) const;
    31	
    32	    Shape* get_transition(string_t name) const;
    33	
    34	    Shape* add_transition(string_t name, MemoryManager* heap);
    35	
    36	    inline uint32_t count() const { return num_fields_; }
    37	    
    38	    void copy_from(const Shape* other) {
    39	        property_offsets_ = other->property_offsets_;
    40	        num_fields_ = other->num_fields_;
    41	    }
    42	    
    43	    void add_property(string_t name) {
    44	        property_offsets_[name] = num_fields_++;
    45	    }
    46	
    47	    size_t obj_size() const noexcept override { return sizeof(Shape); }
    48	
    49	    void trace(GCVisitor& visitor) const noexcept override;
    50	};
    51	
    52	}


================================================================================
 FILE PATH: include/meow/core/string.h
================================================================================
     1	#pragma once
     2	#include <cstdint>
     3	#include <cstring>
     4	#include <string> 
     5	#include <meow/core/meow_object.h>
     6	
     7	namespace meow {
     8	
     9	class ObjString : public ObjBase<ObjectType::STRING> {
    10	private:
    11	    using visitor_t = GCVisitor;
    12	    
    13	    size_t length_;
    14	    size_t hash_;
    15	    char chars_[1]; 
    16	
    17	    friend class MemoryManager;
    18	    friend class heap; 
    19	    
    20	    ObjString(const char* chars, size_t length, size_t hash) 
    21	        : length_(length), hash_(hash) {
    22	        std::memcpy(chars_, chars, length);
    23	        chars_[length] = '\0'; 
    24	    }
    25	
    26	public:
    27	    ObjString() = delete; 
    28	    ObjString(const ObjString&) = delete;
    29	    
    30	    // --- Accessors ---
    31	    inline const char* c_str() const noexcept { return chars_; }
    32	    inline size_t size() const noexcept { return length_; }
    33	    inline bool empty() const noexcept { return length_ == 0; }
    34	    inline size_t hash() const noexcept { return hash_; }
    35	
    36	    inline char get(size_t index) const noexcept { return chars_[index]; }
    37	
    38	    inline void trace(visitor_t&) const noexcept override {}
    39	    
    40	    size_t obj_size() const noexcept override { 
    41	        return sizeof(ObjString) + length_; 
    42	    }
    43	};
    44	
    45	struct ObjStringHasher {
    46	    inline size_t operator()(string_t s) const noexcept {
    47	        return s->hash();
    48	    }
    49	};
    50	}


